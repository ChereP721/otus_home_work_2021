package hw03frequencyanalysis

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

var text = `–ö–∞–∫ –≤–∏–¥–∏—Ç–µ, –æ–Ω  —Å–ø—É—Å–∫–∞–µ—Ç—Å—è  –ø–æ  –ª–µ—Å—Ç–Ω–∏—Ü–µ  –≤—Å–ª–µ–¥  –∑–∞  —Å–≤–æ–∏–º
	–¥—Ä—É–≥–æ–º   –ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä–æ–º   –†–æ–±–∏–Ω–æ–º,   –≥–æ–ª–æ–≤–æ–π   –≤–Ω–∏–∑,  –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞—è
	—Å—Ç—É–ø–µ–Ω—å–∫–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–º –∑–∞—Ç—ã–ª–∫–æ–º:  –±—É–º-–±—É–º-–±—É–º.  –î—Ä—É–≥–æ–≥–æ  —Å–ø–æ—Å–æ–±–∞
	—Å—Ö–æ–¥–∏—Ç—å  —Å  –ª–µ—Å—Ç–Ω–∏—Ü—ã  –æ–Ω  –ø–æ–∫–∞  –Ω–µ  –∑–Ω–∞–µ—Ç.  –ò–Ω–æ–≥–¥–∞ –µ–º—É, –ø—Ä–∞–≤–¥–∞,
		–∫–∞–∂–µ—Ç—Å—è, —á—Ç–æ –º–æ–∂–Ω–æ –±—ã –Ω–∞–π—Ç–∏ –∫–∞–∫–æ–π-—Ç–æ –¥—Ä—É–≥–æ–π —Å–ø–æ—Å–æ–±, –µ—Å–ª–∏ –±—ã  –æ–Ω
	—Ç–æ–ª—å–∫–æ   –º–æ–≥   –Ω–∞  –º–∏–Ω—É—Ç–∫—É  –ø–µ—Ä–µ—Å—Ç–∞—Ç—å  –±—É–º–∫–∞—Ç—å  –∏  –∫–∞–∫  —Å–ª–µ–¥—É–µ—Ç
	—Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏—Ç—å—Å—è. –ù–æ —É–≤—ã - —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏—Ç—å—Å—è-—Ç–æ –µ–º—É –∏ –Ω–µ–∫–æ–≥–¥–∞.
		–ö–∞–∫ –±—ã —Ç–æ –Ω–∏ –±—ã–ª–æ, –≤–æ—Ç –æ–Ω —É–∂–µ —Å–ø—É—Å—Ç–∏–ª—Å—è  –∏  –≥–æ—Ç–æ–≤  —Å  –≤–∞–º–∏
	–ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è.
	- –í–∏–Ω–Ω–∏-–ü—É—Ö. –û—á–µ–Ω—å –ø—Ä–∏—è—Ç–Ω–æ!
		–í–∞—Å,  –≤–µ—Ä–æ—è—Ç–Ω–æ,  —É–¥–∏–≤–ª—è–µ—Ç, –ø–æ—á–µ–º—É –µ–≥–æ —Ç–∞–∫ —Å—Ç—Ä–∞–Ω–Ω–æ –∑–æ–≤—É—Ç, –∞
	–µ—Å–ª–∏ –≤—ã –∑–Ω–∞–µ—Ç–µ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π, —Ç–æ –≤—ã —É–¥–∏–≤–∏—Ç–µ—Å—å –µ—â–µ –±–æ–ª—å—à–µ.
		–≠—Ç–æ –Ω–µ–æ–±—ã–∫–Ω–æ–≤–µ–Ω–Ω–æ–µ –∏–º—è –ø–æ–¥–∞—Ä–∏–ª –µ–º—É –ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä  –†–æ–±–∏–Ω.  –ù–∞–¥–æ
	–≤–∞–º  —Å–∫–∞–∑–∞—Ç—å,  —á—Ç–æ  –∫–æ–≥–¥–∞-—Ç–æ –ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä –†–æ–±–∏–Ω –±—ã–ª –∑–Ω–∞–∫–æ–º —Å –æ–¥–Ω–∏–º
	–ª–µ–±–µ–¥–µ–º –Ω–∞ –ø—Ä—É–¥—É, –∫–æ—Ç–æ—Ä–æ–≥–æ –æ–Ω –∑–≤–∞–ª –ü—É—Ö–æ–º. –î–ª—è –ª–µ–±–µ–¥—è  —ç—Ç–æ  –±—ã–ª–æ
	–æ—á–µ–Ω—å   –ø–æ–¥—Ö–æ–¥—è—â–µ–µ  –∏–º—è,  –ø–æ—Ç–æ–º—É  —á—Ç–æ  –µ—Å–ª–∏  —Ç—ã  –∑–æ–≤–µ—à—å  –ª–µ–±–µ–¥—è
	–≥—Ä–æ–º–∫–æ: "–ü—É-—É—Ö! –ü—É-—É—Ö!"- –∞ –æ–Ω  –Ω–µ  –æ—Ç–∫–ª–∏–∫–∞–µ—Ç—Å—è,  —Ç–æ  —Ç—ã  –≤—Å–µ–≥–¥–∞
	–º–æ–∂–µ—à—å  —Å–¥–µ–ª–∞—Ç—å –≤–∏–¥, —á—Ç–æ —Ç—ã –ø—Ä–æ—Å—Ç–æ –ø–æ–Ω–∞—Ä–æ—à–∫—É —Å—Ç—Ä–µ–ª—è–ª; –∞ –µ—Å–ª–∏ —Ç—ã
	–∑–≤–∞–ª –µ–≥–æ —Ç–∏—Ö–æ, —Ç–æ –≤—Å–µ –ø–æ–¥—É–º–∞—é—Ç, —á—Ç–æ —Ç—ã  –ø—Ä–æ—Å—Ç–æ  –ø–æ–¥—É–ª  —Å–µ–±–µ  –Ω–∞
	–Ω–æ—Å.  –õ–µ–±–µ–¥—å  –ø–æ—Ç–æ–º  –∫—É–¥–∞-—Ç–æ –¥–µ–ª—Å—è, –∞ –∏–º—è –æ—Å—Ç–∞–ª–æ—Å—å, –∏ –ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä
	–†–æ–±–∏–Ω —Ä–µ—à–∏–ª –æ—Ç–¥–∞—Ç—å –µ–≥–æ —Å–≤–æ–µ–º—É –º–µ–¥–≤–µ–∂–æ–Ω–∫—É, —á—Ç–æ–±—ã –æ–Ω–æ –Ω–µ  –ø—Ä–æ–ø–∞–ª–æ
	–∑—Ä—è.
		–ê  –í–∏–Ω–Ω–∏ - —Ç–∞–∫ –∑–≤–∞–ª–∏ —Å–∞–º—É—é –ª—É—á—à—É—é, —Å–∞–º—É—é –¥–æ–±—Ä—É—é –º–µ–¥–≤–µ–¥–∏—Ü—É
	–≤  –∑–æ–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–º  —Å–∞–¥—É,  –∫–æ—Ç–æ—Ä—É—é  –æ—á–µ–Ω—å-–æ—á–µ–Ω—å  –ª—é–±–∏–ª  –ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä
	–†–æ–±–∏–Ω.  –ê  –æ–Ω–∞  –æ—á–µ–Ω—å-–æ—á–µ–Ω—å  –ª—é–±–∏–ª–∞  –µ–≥–æ. –ï–µ –ª–∏ –Ω–∞–∑–≤–∞–ª–∏ –í–∏–Ω–Ω–∏ –≤
	—á–µ—Å—Ç—å –ü—É—Ö–∞, –∏–ª–∏ –ü—É—Ö–∞ –Ω–∞–∑–≤–∞–ª–∏ –≤ –µ–µ —á–µ—Å—Ç—å - —Ç–µ–ø–µ—Ä—å —É–∂–µ –Ω–∏–∫—Ç–æ  –Ω–µ
	–∑–Ω–∞–µ—Ç,  –¥–∞–∂–µ –ø–∞–ø–∞ –ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä–∞ –†–æ–±–∏–Ω–∞. –ö–æ–≥–¥–∞-—Ç–æ –æ–Ω –∑–Ω–∞–ª, –∞ —Ç–µ–ø–µ—Ä—å
	–∑–∞–±—ã–ª.
		–°–ª–æ–≤–æ–º, —Ç–µ–ø–µ—Ä—å –º–∏—à–∫—É –∑–æ–≤—É—Ç –í–∏–Ω–Ω–∏-–ü—É—Ö, –∏ –≤—ã –∑–Ω–∞–µ—Ç–µ –ø–æ—á–µ–º—É.
		–ò–Ω–æ–≥–¥–∞ –í–∏–Ω–Ω–∏-–ü—É—Ö –ª—é–±–∏—Ç –≤–µ—á–µ—Ä–∫–æ–º –≤–æ —á—Ç–æ-–Ω–∏–±—É–¥—å –ø–æ–∏–≥—Ä–∞—Ç—å,  –∞
	–∏–Ω–æ–≥–¥–∞,  –æ—Å–æ–±–µ–Ω–Ω–æ  –∫–æ–≥–¥–∞  –ø–∞–ø–∞  –¥–æ–º–∞,  –æ–Ω –±–æ–ª—å—à–µ –ª—é–±–∏—Ç —Ç–∏—Ö–æ–Ω—å–∫–æ
	–ø–æ—Å–∏–¥–µ—Ç—å —É –æ–≥–Ω—è –∏ –ø–æ—Å–ª—É—à–∞—Ç—å –∫–∞–∫—É—é-–Ω–∏–±—É–¥—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω—É—é —Å–∫–∞–∑–∫—É.
		–í —ç—Ç–æ—Ç –≤–µ—á–µ—Ä...`

func TestTop10(t *testing.T) {
	t.Run("no words in empty string", func(t *testing.T) {
		require.Len(t, Top10(""), 0)
	})

	t.Run("small count words", func(t *testing.T) {
		text := `
1
2 2
3 3 3
4 4 4 4
		`
		expected := []string{
			"4",
			"3",
			"2",
			"1",
		}
		require.Equal(t, expected, Top10(text))
	})

	t.Run("int overage", func(t *testing.T) {
		text := strings.Repeat(" int overage", 128) + " a one word"
		expected := []string{
			"a",
			"one",
			"word",
			"int",
			"overage",
		}
		require.Equal(t, expected, Top10(text))
	})

	t.Run("unicode", func(t *testing.T) {
		text := `
\u0011
\u0012 \u0012
\u0013 \u0013
\u0014 \u0014 \u0014
		`
		expected := []string{
			`\u0014`,
			`\u0012`,
			`\u0013`,
			`\u0011`,
		}
		require.Equal(t, expected, Top10(text))
	})

	t.Run("hard language and emoji", func(t *testing.T) {
		text := `
‰Ω†
Â•Ω Â•Ω
Á¨¨ Á¨¨ Á¨¨ Á¨¨
‰∏â ‰∏â ‰∏â ‰∏â
ü§Ø ü§Ø ü§Ø ü§Ø
üòÄ üòÄ üòÄ üòÄ
ü§ó ü§ó ü§ó ü§ó ü§ó
‚ò† ‚ò† ‚ò† ‚ò† ‚ò†
		`
		expected := []string{
			"‚ò†",
			"ü§ó",
			"‰∏â",
			"Á¨¨",
			"üòÄ",
			"ü§Ø",
			"Â•Ω",
			"‰Ω†",
		}
		require.Equal(t, expected, Top10(text))
	})

	taskWithAsteriskIsCompleted = false
	t.Run("positive test", func(t *testing.T) {
		expected := []string{
			"–æ–Ω",        // 8
			"–∞",         // 6
			"–∏",         // 6
			"—Ç—ã",        // 5
			"—á—Ç–æ",       // 5
			"-",         // 4
			"–ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä", // 4
			"–µ—Å–ª–∏",      // 4
			"–Ω–µ",        // 4
			"—Ç–æ",        // 4
		}
		require.Equal(t, expected, Top10(text))
	},
	)

	taskWithAsteriskIsCompleted = true
	t.Run("positive test with asterisk", func(t *testing.T) {
		expected := []string{
			"–∞",         // 8
			"–æ–Ω",        // 8
			"–∏",         // 6
			"—Ç—ã",        // 5
			"—á—Ç–æ",       // 5
			"–≤",         // 4
			"–µ–≥–æ",       // 4
			"–µ—Å–ª–∏",      // 4
			"–∫—Ä–∏—Å—Ç–æ—Ñ–µ—Ä", // 4
			"–Ω–µ",        // 4
		}
		require.Equal(t, expected, Top10(text))
	},
	)
}

func TestNormalizeWord(t *testing.T) {
	tests := []struct {
		name       string
		input      string
		expected   string
		expectedWA string
	}{
		{name: "simple word", input: "–ö–∞–∫", expected: "–ö–∞–∫", expectedWA: "–∫–∞–∫"},
		{name: "dash word", input: " - ", expected: "-", expectedWA: ""},
		{name: "punctuation marks", input: "–≤–∏–¥–∏—Ç–µ,", expected: "–≤–∏–¥–∏—Ç–µ,", expectedWA: "–≤–∏–¥–∏—Ç–µ"},
		{name: "word with hyphen", input: "–±—É–º-–±—É–º-–±—É–º", expected: "–±—É–º-–±—É–º-–±—É–º", expectedWA: "–±—É–º-–±—É–º-–±—É–º"},
		{name: "word with hyphen at end", input: "–±—É–º-–±—É–º-–±—É–º-", expected: "–±—É–º-–±—É–º-–±—É–º-", expectedWA: "–±—É–º-–±—É–º-–±—É–º"},
	}
	for _, tc := range tests {
		tc := tc
		taskWithAsteriskIsCompleted = false
		t.Run(tc.name+" ("+tc.input+")", func(t *testing.T) {
			result := normalizeWord(tc.input)
			require.Equal(t, tc.expected, result)
		})
		taskWithAsteriskIsCompleted = true
		t.Run(tc.name+" with asterisk ("+tc.input+")", func(t *testing.T) {
			result := normalizeWord(tc.input)
			require.Equal(t, tc.expectedWA, result)
		})
	}
}
